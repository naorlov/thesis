\documentclass[../diploma.tex]{subfile}


\begin{document}
    \section{Мой вклад}\label{sec:results}

    \subsection{Предлагаемое решение}
    \label{sec:results:subsec:proposal}

    Мое решение является логическим продолжением решения, представленного в
    статье BTeHadoop2\cite{baseline_model}. 

    Моделирование работы MapReduce системы осуществляется комбинированным
    подходом методов дискретно-событийного и аналитического моделирования.
    Межпроцессное взаимодействие, работа подсистемы хранения данных, алгоритмы
    планирования и коммуникация координатора с исполнителями описываются в
    терминах ДСМ. 
    
    При этом моделирование задач, отвечающих заданиям MapReduce-приложения,
    осуществляется с помощью аналитической модели. В данном контексте,
    аналитическая модель представляет из себя функцию, сопоставляющую размер
    входных данных для каждой задачи и время, которое будет потрачено задачей на
    обработку этого объема данных.

    Поиск такой модели осуществляется методами машинного обучения. Для упрощения
    реализации класс функций, среди которых осуществляется поиск, ограничен
    следующим семейством:
    
    \begin{equation} 
        \label{eq:model}
        f(n) = \sum_{i = 0}^d a_in^i + \sum_{i=0}^d b_in^i\log(n)
    \end{equation} 

    Здесь $n$ -- размер входных данных, $d$ -- степень многочлена, $a_i, b_i$ --
    коэффициенты, определяющие конкретную функцию среди семейства. Размер
    входных данных может быть либо количеством байт, либо количеством строк.

    Данное семейство взято исходя из следующего предположения: в подавляющем
    большинстве случаев Map задача ответственна за трансформацию каждой
    конкретной строки и пишет либо равное, либо логарифмически отличающееся
    количество строк от входных данных. На этапе же Reduce-шага, опять же, в
    подавляющем большинстве случаев, происходит агрегация строк, которая может
    быть как линейной по сложности (например, сумма, среднее или максимум
    значений среди одного ключа), так и иметь сложность $O(n\log n)$ и более
    высокого порядка (сортировка значений, подсчет наибольшей общей
    подпоследовательности между ключом и значением и прочее).

 
    \subsection{Требования к реализации}
    \label{sec:results:subsec:requirements}

    Были выдвинуты следующие требования к реализации предложенного решения:

    \begin{itemize}
        \item Реализация должна быть легко расширяемой и поддерживать разные
              алгоритмы планирования последовательности запуска задач, в том
              числе реализованные пользователем.
        \item Реализация должна показывать хорошую точность моделирования,
              выдавая время выполнения MapReduce-приложения близкое к выполнению
              на реальном кластере.
    \end{itemize}

    \subsection{Описание реализации}
    \label{sec:results:subsec:final}

    В рамках выполнения дипломной работы было создано два программных модуля:
    \texttt{mrss-analyzer} и \texttt{mrss-simulator}.

    \subsubsection{Пререквизиты}

    Для работы с симулятором пользователю необходимо удостовериться, что
    выполнены следующие требования и ограничения:

    \begin{enumerate}
        \item Каждое задание MapReduce приложения является бинарным исполняемым
              файлом, производящим чтение входных данных со стандартного ввода,
              и записывающим результат на стандартный вывод
        \item Задания могут быть объединены в произвольную последовательность
        \item Для задания, исполняющегося первым, задан набор файлов, являющийся
              эталонным и представляющий исходное распределение данных
    \end{enumerate}

    \subsubsection{Конфигурация задачи}

    В рамках дипломной работы был принят упрощенный формат настройки MapReduce
    приложения. Пользователь указывает следующие параметры:
    
    \begin{itemize}
        \item Версию конфигурационного файла
        \item Размер входных данных, подаваемых первому по порядку шагу вычислений
        \item Путь к исполняемым файлам для каждой задачи вычислений
        \item Путь к входным данным для каждой задачи вычислений, либо, если
              таких данных нет, путь к входным данным для первой задачи в
              последовательности вычислений
    \end{itemize}

    Пример описания приведен в Листинге \ref{lst:specfile} (в Приложении). 
    
    \subsubsection{Анализатор MapReduce-задачи}

    На основе конфигурационного файла проводится тестирование шагов указанной
    MapReduce\hyp{}задачи с помощью утилиты {\tt mrss-analyzer}. Результатом
    тестирования является модель времени исполнения и объема выходных данных
    шага задачи.

    Каждый шаг запускается несколько раз на каждом входном файле, которые
    указаны в конфигурационном файле (по умолчанию 10), после чего считается
    среднее значение среди 95-процентиля всех значений. Это позволяет избавиться
    от выбросов в данных, которые неизбежно появляются из-за особенностей работы
    операционной системы. В итоге получается набор точек $(n_i, t_i)$, где $n_i$
    -- размер входных данных в строках, $t_i$ -- время исполнения шага,
    отвечающее соответствующему размеру входных данных, умноженное на тактовую 
    частоту процессора хоста, на котором запускается анализ MapReduce-задачи.

    В случае, если входные данные предоставлены только для первого шага
    вычислений, утилита будет сохранять промежуточные файлы на диск, для
    последующего их использования в следующем шаге вычислений.
    
    После этого создается модель количества выходных строк, производимых после
    каждого шага вычислений. Модель строится по точкам $(n_i, t_i)$ с помощью
    регрессии на коэффициенты $a_i, b_i$ из \ref{eq:model}. Для этого точки
    представляются в виде векторов $(n_i)_{i < I}, (t_i)_{i < I}$, где $I$ --
    количество различных точек, после чего вычисляется матрицы $A, B$, составленные из
    столбцов $n, n^2, n^3, \ldots, n^d$ и $\log(n)\cdot n, \log(n)\cdot n^2,
    \ldots, \log(n)\cdot n^d$ соответственно, где операции возведения в степень и
    логарифмирования являются поэлементными.

    Получившаяся выборка делится на тренировочную и тестовую в пропорции 80/20.
    После этого с помощью линейной регрессии ищутся коэффициенты для следующего
    уравнения:
    
    \begin{equation}
        a\times A + b \times B = t
    \end{equation}

    Для оптимизации вычисления и упрощения кода матрицы $A$ и $B$ представляются
    в конкатенированном виде $A\circ B$ вдоль строк. 

    Данная процедура проводится для всех $d$, меньших чем указанная
    пользователем степень (по умолчанию 10). После этого считается $R^2$ метрика
    качества каждой модели на тестовой выборке, по которой выбирается модель с
    максимальным значением метрики. 

    Результатом работы этого этапа является текстовый файл с описанием сложности
    по времени и по памяти каждого шага вычислений. Пример такого файла приведен
    в Листинге \ref{lst:resultfile} (в Приложении).

    \subsubsection{Симулятор MapReduce}
    
    Симулятор {\tt mrss-simulator} построен на базе фреймворка SimGrid
    \cite{simgrid}\cite{simgrid_paper}, позволяющего с легкостью описать
    распределенную систему в акторной модели. Симулятор работает с
    конфигурационным файлом, полученным от пользователя, файлом описания
    платформы и файлом результатов тестирования, полученным на этапе
    тестирования. 

    Для каждого шага симулятор создает <<задание>> на исполнение, состоящее из
    объема входных данных, функции зависимости времени выполнения и объема
    выходных данных для этого шага. Затем, для каждого сервера в эмулируемом
    кластере создается свой актор, ответственный за работу этого узла кластера.

    Актор отвечает за моделирование чтения данных из источника (может быть либо
    локальным диском, либо удаленным хостом), моделирование исполнения задачи с
    помощью данных, полученных на шаге анализа данных и моделирования записи
    данных в локальную или удаленную файловую систему. 
    
    Каждый актор использует вызовы фреймворка SimGrid для симуляции исполнения
    шага MapReduce-задачи на узле, а именно чтение данных из распределенной
    файловой системы, выполнение программы и запись данных в файловую систему. В
    текущей реализации подразумевается, что входные данные равномерно
    распределены по хостам кластера.
    
    Параметры исполнения одной задачи определяются {\it координатором} --
    специальным актором, являющимся ответственным за отправку задач на
    исполнение заданий в соответствии с указанием {\it планировщика}. 

    В симуляторе поддержана функциональность использования собственноручно
    написанного алгоритма планирования вычисления. В процессе симуляции
    координатор может обращаться к планировщику, представленному пользователем,
    для определения порядка выполнения задач. 

    Моделирование исполнения задачи происходит с помощью модели, полученной на
    шаге анализа соответствующего задания. Для симуляции времени выполнения
    фреймворк SimGrid использует параметр <<количество операций с плавающей
    запятой>>, исходя из предположения, что за один такт моделируемого хоста
    происходит одна операция с плавающей запятой. Так как во время анализа
    происходит регрессия на количество операций в зависимости от размера входных
    данных, пропадает зависимость времени выполнения от скорости моделируемого
    хоста либо хоста, на котором происходил анализ данных.


\end{document}


